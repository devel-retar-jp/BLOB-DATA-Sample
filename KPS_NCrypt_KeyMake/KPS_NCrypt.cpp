/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 
/// CNG Key Storage Providers
/// キー生成
/// 
/// Summary:
/// 暗号化には①対称鍵と②非対称鍵の方式があります。
/// CNG Key Storage Providersは非対称鍵
/// OS内に保存されている秘密キーを呼び出します。
/// 秘密鍵が移動プロファイルに保存されるため、ソフトウェアライセンスなどで使います。
///  
/// 2021/08/09      Retar.jp
/// 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <Windows.h>
#include <ncrypt.h>
#include <iostream>
#include <vector>
#include <iterator>
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <random>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "functions.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma comment (lib, "ncrypt.lib")
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main()
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//コンソールの扱いをUTF-8に変更
	SetConsoleOutputCP(CP_UTF8);
	setvbuf(stdout, nullptr, _IOFBF, 4096);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//bin拡張子はバイナリ、そのまま読み込み使えます。
	//txt拡張子はテキストファイル・入力も出力も好きなフォーマットでOK
	std::wstring InFileName = L"InText.txt";											//テスト入力ファイル名UNICODE指定	
	std::wstring privateKeyData = L"privateKey.bin";									//Private鍵・乱数で設定
	std::wstring publicKeyData = L"publicKey.bin";										//Public鍵・乱数で設定
	std::wstring cryptProtectData = L"CryptProtectData.bin";							//暗号化バイナリ出力ファイル名・UNICODE指定	
	std::wstring decryptProtectData = L"DeCryptProtectData.txt";						//復号ファイル出力ファイル名・UNICODE指定	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//ディレクトリ設定
	auto InFilePath = makeFilePath(&InFileName);
	auto privateKeyDataPath = makeFilePath(&privateKeyData);
	auto publicKeyDataPath = makeFilePath(&publicKeyData);
	auto cryptProtectPath = makeFilePath(&cryptProtectData);
	auto decryptProtectDataPath = makeFilePath(&decryptProtectData);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//ファイル読み込み
	std::vector<BYTE>  ifsInDataBYTE = readFileData(&InFilePath[0]);					//ファイル読み込み
	//binStdOut((LPBYTE)&ifsInDataBYTE[0], (unsigned long)ifsInDataBYTE.size(), "In File : ");
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	NCRYPT_PROV_HANDLE hProvider = NULL;												//アルゴリズムハンドラ
	NTSTATUS status = STATUS_UNSUCCESSFULL;												//関数のレスポンス・ステータス
	NCRYPT_KEY_HANDLE  hKey = NULL;														//キーハンドラ
	WCHAR              szKeyName[] = L"NCryptSaveKey";									//保存名・名前が重要！！！！・特段のキーロックなどを設けなければ誰でもキーアクセスできます
	ULONG	cbData;																		//サイズ用のバッファー・テンポラリとして使っています
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//アルゴリズムプロバイダオープン
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//アルゴリズムプロバイダオープン
	statusCheck(
		NCryptOpenStorageProvider(
			&hProvider																	//ハンドラのポインタ
			, MS_KEY_STORAGE_PROVIDER													//ストレージプロバイダの呼び出し
			, 0																			//Flag
		)
		, L"NCryptOpenStorageProvider Open : MS_KEY_STORAGE_PROVIDER"					//CNG Key Storage Providersを指定する
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// キーをオープンする
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//キーをオープンする
	status = NCryptOpenKey(
		hProvider																		//ハンドラのポインタ
		, &hKey																			//キーハンドラ
		, szKeyName																		//保存名・名前が重要！！！！・特段のキーロックなどを設けなければ誰でもキーアクセスできます
		, 0																				//キーの種類
		, 0																				//Flag
	);					
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//キーが存在するため一旦消して、終了
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (status == ERROR_SUCCESS) {
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//キーが存在する場合
		std::cout << "Key Exsist :" << std::endl;
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		statusCheck(
			NCryptDeleteKey(
				hKey																	//キーハンドラ
				, 0																		//Flag
			)
			, L"NCryptDeleteKey : "
		);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//アルゴリズムプロバイダクローズ
		//statusCheck(
		//	NCryptFreeObject(hKey)
		//	, L"NCryptFreeObject Close : hKey"
		//);
		statusCheck(
			NCryptFreeObject(hProvider)
			, L"NCryptFreeObject Close : hProvider"
		);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//終了
		return 0;
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//キーが存在しないため新規製造
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//キーが存在しないため新規製造・キーを消さないとエラーになる
	std::cout << "Key Does Not Exsist :" << std::endl;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//新しいキーを製造して保存する
	statusCheck(
		NCryptCreatePersistedKey(
			hProvider
			, &hKey																		//キーハンドラ
			, NCRYPT_RSA_ALGORITHM														//RSAを指定
			//, BCRYPT_ECDSA_P256_ALGORITHM
			//, BCRYPT_ECDSA_P384_ALGORITHM
			//, BCRYPT_ECDSA_P521_ALGORITHM
			, szKeyName																	//保存名・名前が重要！！！！・特段のキーロックなどを設けなければ誰でもキーアクセスできます
			, 0																			//キーの種類
			, NCRYPT_OVERWRITE_KEY_FLAG													//存在していたら消すにしていますが、常にオーバーライトするモードもあります
		)
		, L"NCryptCreatePersistedKey : "
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////プロパティでキーレングス調整
	DWORD keyLen = 512*8;																//RSA -> 512 * x -> MAX 16384(512*32)・512バイトの倍数にしないとエラーになります。1～32の間で。
	statusCheck(
		NCryptSetProperty(
			hKey																		//キーハンドラ
			, NCRYPT_LENGTH_PROPERTY													//長さ調整
			, (PBYTE)&keyLen															//設定長
			, sizeof(keyLen)															//キーサイズのバイト数
			, NCRYPT_PERSIST_FLAG														//hKeyが指定されている時は必要						
		)
		, L"NCryptSetProperty : Key Length"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////プロパティでパスワード要求
	// 	キーアクセス時にパスワード要求したいなら、こちらです。
	//NCRYPT_UI_POLICY        UIPolicy = { 0 };
	//ZeroMemory(&UIPolicy, sizeof(UIPolicy));
	//UIPolicy.dwVersion = 1;
	//UIPolicy.dwFlags = NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG;
	//UIPolicy.pszCreationTitle = L"Key Title";
	//UIPolicy.pszFriendlyName = L"Key Name";
	//UIPolicy.pszDescription = L"Key Description";
	//statusCheck(
	//	NCryptSetProperty(
	//		hKey																		//キーハンドラ
	//		,NCRYPT_UI_POLICY_PROPERTY													//ポリシー
	//		,(PBYTE)&UIPolicy															//ポリシー構造体のアドレス
	//		,sizeof(UIPolicy)															//ポリシー構造体のサイズ
	//		,0
	//	)
	//	, L"NCryptSetProperty : Key Password Setting"
	//);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//新しいキーを保存・保存しないと使えない
	//移動プロファイルごと持って歩くスタイル
	// %AppData%\Microsoft\Crypto\Keys	保存場所
	statusCheck(
		NCryptFinalizeKey(
			hKey																		//キーハンドラ
			, 0																			//Flag
		)
		, L"NCryptFinalizeKey : Save"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// キーを生成して保存する
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//PublicKeyキー・BLOB生成・サイズ確認
	DWORD dwPublicDataSize;
	statusCheck(
		NCryptExportKey(
			hKey																		//キーオブジェクト
			, NULL																		//AES以外はNULL
			, BCRYPT_PUBLIC_KEY_BLOB													//専用の定数があるが、汎用にしておくとアルゴリズムを変えてもOK、扱いが楽！
			, NULL																		//キー情報が得られるらしいが、必要ないのでNULL
			, NULL																		//サイズを測るだけなのでNULL
			, 0																			//サイズを測るだけなので0
			, &dwPublicDataSize															//サイズを取得
			, 0																			//フラグなし
		)
		, L"NCryptExportKey : PublicKey : Size"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//PublicKeyキー・生成・保存
	std::vector<BYTE> dwPublicData(dwPublicDataSize, NULL);								//バイト長さ、初期化データ
	statusCheck(
		NCryptExportKey(
			hKey																		//キーオブジェクト
			, NULL																		//AES以外はNULL
			, BCRYPT_PUBLIC_KEY_BLOB													//専用の定数があるが、汎用にしておくとアルゴリズムを変えてもOK、扱いが楽！
			, NULL																		//キー情報が得られるらしいが、必要ないのでNULL
			, &dwPublicData[0]															//データ領域
			, dwPublicDataSize															//データサイズ
			, &cbData																	//テンポラリ
			, 0																			//フラグ
		)
		, L"NCryptExportKey : PublicKey : Make"
	);
	//バイナリファイル書き出し・最後の引数は（16/10/0）。カギとしてバイナリ保存するときは「０」書き出し。Debugしやすいようになっています。
	//今回は再読み込みなので「０」
	writeFileData((LPBYTE)&dwPublicData[0], (unsigned long)dwPublicData.size(), &publicKeyData, 0);
	//コンソール出力
	binStdOut((LPBYTE)&dwPublicData[0], (unsigned long)dwPublicData.size(), "Public Key : ");
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//PrivateKeyを取り出そうとするとエラーになります。仕様上できません
	//BCryptとは違う所です。
	// 
	////PrivateKeyキー・BLOB生成・サイズ確認
	//DWORD dwPrivateDataSize;
	//statusCheck(
	//	NCryptExportKey(
	//		hKey																		//キーオブジェクト
	//		, NULL																		//AES以外はNULL
	//		, BCRYPT_PRIVATE_KEY_BLOB													//専用の定数があるが、汎用にしておくとアルゴリズムを変えてもOK、扱いが楽！
	//		, NULL																		//キー情報が得られるらしいが、必要ないのでNULL
	//		, NULL																		//サイズを測るだけなのでNULL
	//		, 0																			//サイズを測るだけなので0
	//		, &dwPrivateDataSize														//サイズを取得
	//		, 0																			//フラグ
	//	)
	//	, L"NCryptExportKey : PrivateKey : Size"
	//);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//キーを解放
	statusCheck(
		NCryptFreeObject(hKey)
		, L"NCryptFreeObject Close : hKey"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//　アルゴリズムプロバイダクローズ
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	statusCheck(
		NCryptFreeObject(hProvider)
		, L"NCryptFreeObject Close : hProvider"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
