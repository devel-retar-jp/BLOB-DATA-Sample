/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 
/// CNG TPM2.0
/// キー生成
/// 
/// Summary:
/// 暗号化には①対称鍵と②非対称鍵の方式があります。
/// CNG Key Storage Providersの半導体保存型がTPM2.0です。
/// 半導体内に保存されている秘密キーを呼び出します。
/// 秘密鍵をファイル保存できないため、
/// 移動プロファイルよりも更に強力なキー保存ができます。
/// 
/// 基本的にはKey Storage Providersと同じ手順です。
///  
/// 2021/08/09      Retar.jp
/// 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <Windows.h>
#include <ncrypt.h>
#include <iostream>
#include <vector>
#include <iterator>
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <random>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "functions.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma comment (lib, "ncrypt.lib")
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main()
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//コンソールの扱いをUTF-8に変更
	SetConsoleOutputCP(CP_UTF8);
	setvbuf(stdout, nullptr, _IOFBF, 4096);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//bin拡張子はバイナリ、そのまま読み込み使えます。
	//txt拡張子はテキストファイル・入力も出力も好きなフォーマットでOK
	std::wstring InFileName = L"InText.txt";											//テスト入力ファイル名UNICODE指定	
	std::wstring privateKeyData = L"privateKey.bin";									//Private鍵・乱数で設定
	std::wstring publicKeyData = L"publicKey.bin";										//Public鍵・乱数で設定
	std::wstring cryptProtectData = L"CryptProtectData.bin";							//暗号化バイナリ出力ファイル名・UNICODE指定	
	std::wstring decryptProtectData = L"DeCryptProtectData.txt";						//復号ファイル出力ファイル名・UNICODE指定	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//ディレクトリ設定
	auto InFilePath = makeFilePath(&InFileName);
	auto privateKeyDataPath = makeFilePath(&privateKeyData);
	auto publicKeyDataPath = makeFilePath(&publicKeyData);
	auto cryptProtectPath = makeFilePath(&cryptProtectData);
	auto decryptProtectDataPath = makeFilePath(&decryptProtectData);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//ファイル読み込み
	std::vector<BYTE>  ifsInDataBYTE = readFileData(&InFilePath[0]);					//ファイル読み込み
	//binStdOut((LPBYTE)&ifsInDataBYTE[0], (unsigned long)ifsInDataBYTE.size(), "In File : ");
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	NCRYPT_PROV_HANDLE hProvider = NULL;												//アルゴリズムハンドラ
	NTSTATUS status = STATUS_UNSUCCESSFULL;												//関数のレスポンス・ステータス
	NCRYPT_KEY_HANDLE  hKey = NULL;														//キーハンドラ
	WCHAR              szKeyName[] = L"TPM20SaveKey";									//保存名・名前が重要！！！！・特段のキーロックなどを設けなければ誰でもキーアクセスできます
	ULONG	cbData;																		//サイズ用のバッファー・テンポラリとして使っています
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//アルゴリズムプロバイダオープン
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//アルゴリズムプロバイダオープン
	statusCheck(
		NCryptOpenStorageProvider(
			&hProvider																	//ハンドラのポインタ
			, MS_PLATFORM_CRYPTO_PROVIDER												//TPM2.0を呼び出し
			, 0																			//Flag
		)
		, L"NCryptOpenStorageProvider Open : MS_PLATFORM_CRYPTO_PROVIDER : TPM2.0"		//CNG TPM2.0を指定する
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//新しいキーを製造して保存する・上書き指定
	statusCheck(
		NCryptCreatePersistedKey(
			hProvider
			, &hKey																		//キーハンドラ
			, NCRYPT_RSA_ALGORITHM														//RSAを指定
			, szKeyName																	//保存名・名前が重要！！！！・特段のキーロックなどを設けなければ誰でもキーアクセスできます
			, 0																			//キーの種類
			, NCRYPT_OVERWRITE_KEY_FLAG													//存在していたら消すにしていますが、常にオーバーライトするモードもあります
		)
		, L"NCryptCreatePersistedKey : "
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////プロパティでキーレングス調整
	//キーレングスが2048ビット以下。
	DWORD keyLen = 512 * 4;																//RSA -> 512 * x -> MAX 2048(512*4)・512バイトの倍数にしないとエラーになります。1～32の間で。
	statusCheck(
		NCryptSetProperty(
			hKey																		//キーハンドラ
			, NCRYPT_LENGTH_PROPERTY													//長さ調整
			, (PBYTE)&keyLen															//設定長
			, sizeof(keyLen)															//キーサイズのバイト数
			, NCRYPT_PERSIST_FLAG														//hKeyが指定されている時は必要						
		)
		, L"NCryptSetProperty : Key Length"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//新しいキーを保存・保存しないと使えない
	statusCheck(
		NCryptFinalizeKey(
			hKey																		//キーハンドラ
			, 0																			//Flag
		)
		, L"NCryptFinalizeKey : Save"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// キーBLOBを生成して保存する
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//PublicKeyキー・BLOB生成・サイズ確認
	DWORD dwPublicDataSize;
	statusCheck(
		NCryptExportKey(
			hKey																		//キーオブジェクト
			, NULL																		//AES以外はNULL
			, BCRYPT_PUBLIC_KEY_BLOB													//専用の定数があるが、汎用にしておくとアルゴリズムを変えてもOK、扱いが楽！
			, NULL																		//キー情報が得られるらしいが、必要ないのでNULL
			, NULL																		//サイズを測るだけなのでNULL
			, 0																			//サイズを測るだけなので0
			, &dwPublicDataSize															//サイズを取得
			, 0																			//フラグなし
		)
		, L"NCryptExportKey : PublicKey : Size"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//PublicKeyキー・生成・保存
	std::vector<BYTE> dwPublicData(dwPublicDataSize, NULL);								//バイト長さ、初期化データ
	statusCheck(
		NCryptExportKey(
			hKey																		//キーオブジェクト
			, NULL																		//AES以外はNULL
			, BCRYPT_PUBLIC_KEY_BLOB													//専用の定数があるが、汎用にしておくとアルゴリズムを変えてもOK、扱いが楽！
			, NULL																		//キー情報が得られるらしいが、必要ないのでNULL
			, &dwPublicData[0]															//データ領域
			, dwPublicDataSize															//データサイズ
			, &cbData																	//テンポラリ
			, 0																			//フラグ
		)
		, L"NCryptExportKey : PublicKey : Make"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//バイナリファイル書き出し・最後の引数は（16/10/0）。カギとしてバイナリ保存するときは「０」書き出し。Debugしやすいようになっています。
	//今回は再読み込みなので「０」
	writeFileData((LPBYTE)&dwPublicData[0], (unsigned long)dwPublicData.size(), &publicKeyData, 0);
	//コンソール出力
	binStdOut((LPBYTE)&dwPublicData[0], (unsigned long)dwPublicData.size(), "Public Key : ");
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//キーを解放
	statusCheck(
		NCryptFreeObject(hKey)
		, L"NCryptFreeObject Close : hKey"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//　アルゴリズムプロバイダクローズ
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	statusCheck(
		NCryptFreeObject(hProvider)
		, L"NCryptFreeObject Close : hProvider"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
