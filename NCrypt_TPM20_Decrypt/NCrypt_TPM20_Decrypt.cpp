/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 
/// CNG TPM2.0
/// 復号化
/// 
/// Summary:
/// 暗号化には①対称鍵と②非対称鍵の方式があります。
/// CNG Key Storage Providersの半導体保存型がTPM2.0です。
/// 半導体内に保存されている秘密キーを呼び出します。
/// 秘密鍵をファイル保存できないため、
/// 移動プロファイルよりも更に強力なキー保存ができます。
/// 
/// 基本的にはKey Storage Providersと同じ手順です。
///  
/// 2021/08/09      Retar.jp
/// 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <Windows.h>
#include <ncrypt.h>
#include <iostream>
#include <vector>
#include <iterator>
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <random>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "functions.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma comment (lib, "ncrypt.lib")
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main()
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//コンソールの扱いをUTF-8に変更
	SetConsoleOutputCP(CP_UTF8);
	setvbuf(stdout, nullptr, _IOFBF, 4096);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//bin拡張子はバイナリ、そのまま読み込み使えます。
	//txt拡張子はテキストファイル・入力も出力も好きなフォーマットでOK
	std::wstring InFileName = L"InText.txt";											//テスト入力ファイル名UNICODE指定	
	std::wstring privateKeyData = L"privateKey.bin";									//Private鍵・乱数で設定
	std::wstring publicKeyData = L"publicKey.bin";										//Public鍵・乱数で設定
	std::wstring cryptProtectData = L"CryptProtectData.bin";							//暗号化バイナリ出力ファイル名・UNICODE指定	
	std::wstring decryptProtectData = L"DeCryptProtectData.txt";						//復号ファイル出力ファイル名・UNICODE指定	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//ディレクトリ設定
	auto InFilePath = makeFilePath(&InFileName);
	auto privateKeyDataPath = makeFilePath(&privateKeyData);
	auto publicKeyDataPath = makeFilePath(&publicKeyData);
	auto cryptProtectPath = makeFilePath(&cryptProtectData);
	auto decryptProtectDataPath = makeFilePath(&decryptProtectData);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//ファイル読み込み
	std::vector<BYTE>  cryptProtectDataBYTE = readFileData(&cryptProtectPath[0]);		//ファイル読み込み
	//binStdOut((LPBYTE)&ifsInDataBYTE[0], (unsigned long)ifsInDataBYTE.size(), "In File : ");
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	NCRYPT_PROV_HANDLE hProvider = NULL;												//アルゴリズムハンドラ
	NTSTATUS status = STATUS_UNSUCCESSFULL;												//関数のレスポンス・ステータス
	NCRYPT_KEY_HANDLE  hSavedKey = NULL;														//キーハンドラ
	WCHAR              szKeyName[] = L"TPM20SaveKey";									//保存名・名前が重要！！！！・特段のキーロックなどを設けなければ誰でもキーアクセスできます
	ULONG	cbData;																		//サイズ用のバッファー・テンポラリとして使っています
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//アルゴリズムプロバイダオープン
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//アルゴリズムプロバイダオープン
	statusCheck(
		NCryptOpenStorageProvider(
			&hProvider																	//ハンドラのポインタ
			, MS_PLATFORM_CRYPTO_PROVIDER												//TPM2.0を呼び出し
			, 0																			//Flag
		)
		, L"NCryptOpenStorageProvider Open : MS_PLATFORM_CRYPTO_PROVIDER : TPM2.0"		//CNG TPM2.0を指定する
	);
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////Private Key読み込み

	statusCheck(
		NCryptOpenKey(
			hProvider																	//ハンドラのポインタ
			, &hSavedKey																	//キーハンドラ
			, szKeyName																	//保存名・名前が重要！！！！・特段のキーロックなどを設けなければ誰でもキーアクセスできます
			, 0																			//キーの種類
			, 0																			//Flag
		)
		, L"NCryptOpenKey : Public Key"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// 復号化する
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Private Keyで復号化・出力サイズ測定
	DWORD	cbPlainTextPrivateSize;
	statusCheck(
		NCryptDecrypt(
			hSavedKey																	//秘密鍵のキーオブジェクト
			, &cryptProtectDataBYTE[0]													//暗号化データBLOB
			, (ULONG)cryptProtectDataBYTE.size()										//暗号化データBLOBサイズ
			, NULL																		//NULL指定
			, NULL																		//復号化データBLOB
			, 0																			//復号化データBLOBサイズ
			, &cbPlainTextPrivateSize													//復号化データBLOBサイズ取得
			, NCRYPT_PAD_PKCS1_FLAG														//フラグNCRYPT_PAD_PKCS1_FLAGしか受け付けない・かならずBIT長を揃えましょう！
		)
		, L"NCryptDecrypt : cbPlainTextPrivateSize : Size"
	);
	std::cout << "Private Key : Decrypt Size : " << std::dec << cbPlainTextPrivateSize << " BYTE" << std::endl;
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////Private Keyで復号化・復号化実行
	std::vector<BYTE> pbPlainTextPrivate(cbPlainTextPrivateSize, NULL);					//復号データ初期化
	statusCheck(
		NCryptDecrypt(
			hSavedKey																	//秘密鍵のキーオブジェクト
			, &cryptProtectDataBYTE[0]													//暗号化データBLOB
			, (ULONG)cryptProtectDataBYTE.size()										//暗号化データBLOBサイズ
			, NULL																		//NULL指定
			, &pbPlainTextPrivate[0]													//復号化データBLOB
			, cbPlainTextPrivateSize													//復号化データBLOBサイズ
			, &cbData																	//復号化データBLOBサイズ取得
			, NCRYPT_PAD_PKCS1_FLAG														//フラグNCRYPT_PAD_PKCS1_FLAGしか受け付けない・かならずBIT長を揃えましょう！
		)
		, L"NCryptDecrypt : cbPlainTextPrivate : Execute"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//NULL文字を削除・ブロック単位で復号されるので、最後にNULL文字が追加されます。バイナリファイルは要注意！！！！
	auto e = std::remove(pbPlainTextPrivate.begin(), pbPlainTextPrivate.end(), NULL);
	pbPlainTextPrivate.erase(e, pbPlainTextPrivate.end());
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//バイナリファイル書き出し・最後の引数は（16/10/0）。カギとしてバイナリ保存するときは「０」書き出し。Debugしやすいようになっています。
	//今回は再読み込みなので「０」
	writeFileData((LPBYTE)&pbPlainTextPrivate[0], (unsigned long)pbPlainTextPrivate.size(), &decryptProtectData, 0);
	//コンソール出力
	binStdOut((LPBYTE)&pbPlainTextPrivate[0], (unsigned long)pbPlainTextPrivate.size(), "Plain Text : ");
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//　アルゴリズムプロバイダクローズ
	// 
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	statusCheck(
		NCryptFreeObject(hProvider)
		, L"NCryptFreeObject Close : hProvider"
	);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
